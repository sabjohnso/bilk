#+TITLE: Wile — Open Issues
#+STARTUP: showall

* Known Issues

** TODO Issue 4: =imports_of_scm= already implemented — Phase 3 plan is stale
:PROPERTIES:
:PRIORITY: C
:END:

[[file:PLAN.org][PLAN.org]] Phase 3 lists "Parse top-level =(import ...)= forms from =.scm=
files" as a task, but [[file:lib/dep_graph.ml::let imports_of_scm][=Dep_graph.imports_of_scm=]] was already implemented
during Phase 1. The plan should be updated to mark this task as complete and
remove it from Phase 3's scope.

** TODO Issue 5: =syntax_to_proper_list= duplicated across modules
:PROPERTIES:
:PRIORITY: B
:END:

[[file:lib/dep_graph.ml::let rec syntax_to_proper_list][=Dep_graph.syntax_to_proper_list=]] duplicates
[[file:lib/library.ml][=Library.syntax_to_proper_list=]] (which is not exported in the =.mli=).

Options:
- Export it from =Library.mli= and use it in =Dep_graph=.
- Extract it to a shared =Syntax_util= module.

The duplication is harmless today but will become a maintenance burden if the
=Syntax.t= representation changes.

** TODO Issue 6: Duplicate imports produce duplicate DOT edges
:PROPERTIES:
:PRIORITY: C
:END:

If a =.sld= file imports the same library more than once (e.g. via separate
=(import ...)= declarations), [[file:lib/dep_graph.ml::let to_dot][=Dep_graph.to_dot=]] emits duplicate edges in the
Graphviz output. This is cosmetically ugly and can confuse layout algorithms.

Fix: deduplicate =node.imports= when building the graph, or deduplicate
edges in =to_dot=.

** TODO Issue 7: =is_stale= dep lookup is O(n) per import
:PROPERTIES:
:PRIORITY: C
:END:

[[file:lib/build.ml::let is_stale][=Build.is_stale=]] uses =List.find_opt= to resolve each import name to a
node, making it O(imports × nodes). Since =plan= calls =is_stale= for every
node, the overall complexity is O(nodes × imports × nodes). Fine for dozens
of libraries, but will become quadratic at scale.

Fix: build a =Hashtbl= from =name -> node= once in =plan= and pass it to
=is_stale= (or a private helper) instead of the raw list.

** TODO Issue 8: =is_stale= double-stats the FASL file
:PROPERTIES:
:PRIORITY: C
:END:

[[file:lib/build.ml::let is_stale][=Build.is_stale=]] calls =Fasl.is_cache_valid= (which stats both the =.sld=
and =.fasl=), then immediately stats the =.fasl= again to read
=this_mtime= for the dep-newer check.

Fix: inline the mtime comparison or capture the stat result from a single
call and reuse it.

** TODO Issue 9: =test_execute_error= relies on runtime error, not compile error
:PROPERTIES:
:PRIORITY: C
:END:

[[file:test/test_build.ml::let test_execute_error][=test_execute_error=]] uses =(/ 1 "bad")= which is a runtime type error.
The library body happens to run at load time, so it surfaces during
=ensure_library=, but this is fragile — if the compiler ever constant-folded
or the VM deferred execution, the test might stop raising.

Fix: use a syntax error (e.g. unbalanced parens) or an unresolved import to
guarantee a compile-time failure.

** TODO Issue 10: Property tests use fixed inputs instead of generators
:PROPERTIES:
:PRIORITY: B
:END:

[[file:test/test_build.ml::let test_execute_makes_fresh][=test_execute_makes_fresh=]] and [[file:test/test_build.ml::let test_plan_preserves_topo_order][=test_plan_preserves_topo_order=]] use
=QCheck2.Gen.return ()= with =~count:5=, running the same fixed 2- or 3-node
graph five times. These are effectively example tests.

Fix: generate random graph structures (varying chain length, diamond width,
which nodes start stale), following the pattern in [[file:test/test_dep_graph.ml::let test_topological_order_property][=test_dep_graph.ml=]]
which uses =QCheck2.Gen.int_range= to vary structure.

** TODO Issue 11: CLI pluralization calls =List.length= twice
:PROPERTIES:
:PRIORITY: C
:END:

In [[file:bin/main.ml::let run_build][=run_build=]], the dry-run and build output both compute
=List.length actions= (or =results=) twice — once for the count and once for
the pluralization conditional.

Fix: bind =let n = List.length actions in= and reuse.

** TODO Issue 12: REPL banner ordering
:PROPERTIES:
:PRIORITY: C
:END:

[[file:bin/main.ml::let run_repl][=run_repl=]] prints the project banner, then auto-build output (on
stderr), then the Wile version banner.  The result is:

#+begin_example
Project: my-project 0.1.0
Auto-built 3 libraries.
Wile Scheme 0.1.0
Type ,help for REPL commands, Ctrl-D to exit.
#+end_example

The build output is sandwiched between two banners.  Consider combining
them into a single greeting (e.g. =Wile Scheme 0.1.0 — Project: my-project
0.1.0=) or printing the version line first.

** TODO Issue 13: =,deps= on a builtin library prints a bare name
:PROPERTIES:
:PRIORITY: C
:END:

Typing =,deps (scheme base)= calls [[file:lib/dep_graph.ml::let build_graph][=Dep_graph.build_graph=]] with
=(scheme base)= as the root.  Since builtins are skipped, the node list is
empty.  [[file:lib/dep_graph.ml::let format_tree][=Dep_graph.format_tree=]] then prints =(scheme base)= with no
children and no explanation.

Fix: detect when the root is a builtin (or absent from the node list) and
print a message like "built-in library (no source dependencies)" instead.

** TODO Issue 14: REPL command dispatch is growing long
:PROPERTIES:
:PRIORITY: C
:END:

[[file:bin/main.ml::let handle_repl_command][=handle_repl_command=]] now handles 14 commands via a mix of exact
=match= arms and =String.sub= prefix checks in the fallback =| _= arm.
This pattern is correct but increasingly hard to maintain.

Fix: refactor to a command table (name, arity, handler) and a generic
dispatcher.  Not urgent — the current code is functional — but will become
necessary as more commands are added.

* Phase 6 (Watch Mode) — Minor Issues

** TODO Issue 15: Missing =caml_enter_blocking_section= in inotify C stubs
:PROPERTIES:
:PRIORITY: C
:END:

The =read= call in [[file:lib/inotify_stubs.c::wile_inotify_read][=wile_inotify_read=]] and =inotify_add_watch=
in [[file:lib/inotify_stubs.c::wile_inotify_add_watch][=wile_inotify_add_watch=]] should release the OCaml runtime lock
via =caml_enter_blocking_section= / =caml_leave_blocking_section=.
This follows the pattern used by OCaml's own =unix_read= stub.  In
practice the fd is =IN_NONBLOCK= so =read= returns immediately, but
=inotify_add_watch= can block on directory stat.

** TODO Issue 16: Document fixed-size offsets array in =wile_inotify_read=
:PROPERTIES:
:PRIORITY: C
:END:

[[file:lib/inotify_stubs.c::64][Line 64]]: =int offsets[256]= — each =inotify_event= is at least 16
bytes, so a 4096-byte buffer can hold at most 256 minimum-size events.
The math works out but the assumption is implicit.  Add a comment
documenting why 256 is sufficient.

** TODO Issue 17: C-side mask constant functions allocate boxed =int64= per call
:PROPERTIES:
:PRIORITY: C
:END:

The mask constant C functions ([[file:lib/inotify_stubs.c::95][=wile_in_modify= etc.]]) call
=caml_copy_int64= which heap-allocates a boxed value on every call.
Now that the OCaml side caches them at module init this is only called
once, but if someone calls the externals directly they pay allocation
each time.

** TODO Issue 18: =poll_dirs= uses =ref= while other mutable fields use =mutable=
:PROPERTIES:
:PRIORITY: C
:END:

Style inconsistency in [[file:lib/watch.ml::51][=watch.ml=]]: =inotify_fd= is =mutable= but
=poll_dirs= is a =string list ref=.  Both should use the same mutation
style — prefer =mutable poll_dirs : string list= for consistency with
the rest of the record.

** TODO Issue 19: =scan_mtimes= re-walks =list_dirs_recursive= on every poll
:PROPERTIES:
:PRIORITY: C
:END:

[[file:lib/watch.ml::72][=scan_mtimes=]] calls =list_dirs_recursive= on every poll.
=add_directory_polling= already called it for the initial snapshot.
For large trees this is wasteful.  Acceptable since polling is the
slow path, but caching the directory list and only re-scanning when
new directories appear would improve performance.

** TODO Issue 20: =add_directory_inotify= silences all =Unix_error=, not just =ENOSPC=
:PROPERTIES:
:PRIORITY: C
:END:

[[file:lib/watch.ml::127][=add_directory_inotify=]]: the =try ... with Unix.Unix_error _ -> -1=
catches all Unix errors including genuine failures like =EACCES=.  The
comment says "wd = -1 means ENOSPC" but the catch-all silences other
errors too.  Should at least log =EACCES= and similar permission
errors to stderr.

** TODO Issue 21: =builtins= captured once at REPL start in watch callback
:PROPERTIES:
:PRIORITY: C
:END:

[[file:bin/main.ml::654][=Build.builtin_library_names inst=]] is computed once when the
=on_idle= closure is created.  If the instance's built-in set could
change (unlikely but possible with extensions), this would go stale.

** TODO Issue 22: Watch message can confuse multi-line editor cursor position
:PROPERTIES:
:PRIORITY: C
:END:

The =\r\x1b[K= before the =[watch]= message ([[file:bin/main.ml::681][line 681]]) clears the
current line before printing.  But if the user is mid-typing a
multi-line expression, this writes to the terminal without the line
editor knowing — the next render will be confused about cursor
position.  This is an inherent limitation of the "idle callback writes
to stderr" approach and would require deeper editor integration to
solve.

** TODO Issue 23: =do_build= rebuilds dep graph on every watch iteration
:PROPERTIES:
:PRIORITY: C
:END:

[[file:bin/main.ml::1284][=do_build=]] calls =Dep_graph.build_graph= every time, which re-scans
the filesystem for =.sld= files.  This is correct and intentional (new
files may appear between iterations), but could be optimized by only
re-scanning on =Created= or =Deleted= events and reusing the cached
graph for =Modified=-only batches.

** TODO Issue 24: =make_polling_watcher= doesn't guarantee polling backend in tests
:PROPERTIES:
:PRIORITY: C
:END:

[[file:test/test_watch.ml::29][=make_polling_watcher=]] calls =Watch.create= which uses inotify on
Linux.  The "polling" test group actually exercises the inotify backend
on Linux.  To truly test the polling backend in isolation,
=Watch.create= would need a =~backend= parameter or a separate
constructor.

** TODO Issue 25: Timing-dependent tests in =test_watch.ml=
:PROPERTIES:
:PRIORITY: C
:END:

Several tests in [[file:test/test_watch.ml][=test_watch.ml=]] use =Unix.sleepf 0.05= to ensure
mtime changes.  On a heavily-loaded system or a filesystem with
1-second mtime granularity (e.g. older ext3, FAT), this could be
flaky.  Acceptable for a modern Linux dev machine with sub-second
resolution.

* Phase 9 (Remote Repositories) — Minor Issues

** TODO Issue 26: =syntax_to_proper_list= duplicated in =repository.ml=
:PROPERTIES:
:PRIORITY: B
:END:

[[file:lib/repository.ml::let syntax_to_proper_list][=Repository.syntax_to_proper_list=]] is the same function already
duplicated in [[file:lib/dep_graph.ml::let rec syntax_to_proper_list][=Dep_graph=]], [[file:lib/library.ml][=Library=]], and [[file:lib/package.ml::let rec syntax_to_proper_list][=Package=]].
See Issue 5.  A shared =Syntax_util= module would eliminate all four
copies.

** TODO Issue 27: Repo names with special characters don't round-trip
:PROPERTIES:
:PRIORITY: C
:END:

Repository names are serialized as Scheme symbols in
[[file:lib/repository.ml::let save_repos][=save_repos=]].  Names containing spaces, parentheses,
or other non-identifier characters won't survive a save/load
round-trip, since =Datum.to_string= emits bare symbols and the reader
tokenizes them differently.

Fix: validate repo names on add (reject non-identifier characters),
or quote names as strings instead of symbols.

** TODO Issue 28: =pkg_fetch= gives misleading error when clones are stale
:PROPERTIES:
:PRIORITY: C
:END:

[[file:bin/main.ml::let pkg_fetch][=pkg_fetch=]] scans cached clones for available versions.
If clones are out of date, =scan_versions= silently returns stale
data and the error is "package not found in any repository" — even
if the package exists upstream.

Fix: suggest =wile pkg repo update= in the error message, or
auto-sync before scanning.
